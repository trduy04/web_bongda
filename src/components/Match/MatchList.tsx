import React, { useState, useEffect } from 'react'
import MatchItem from './MatchItem'
import LeagueHeader from './LeagueHeader'
import { footballApi, type Competition, type Match } from '../../services/footballApi'
import './MatchList.scss'

interface MatchData {
	id: string
	homeTeam: {
		name: string
		score?: number | null
		logo: string
	}
	awayTeam: {
		name: string
		score?: number | null
		logo: string
	}
	time: string
	status: 'finished' | 'live' | 'upcoming'
}

interface LeagueData {
	id: number
	name: string
	countryFlag: string
	countryName: string
	leagueEmblem?: string
	matches: MatchData[]
}

interface MatchListProps {
	selectedLeagueId?: number | null
	selectedDate?: string | null
	activeFilter?: string
}

const MatchList: React.FC<MatchListProps> = ({ selectedLeagueId, selectedDate, activeFilter }) => {
	const [leagues, setLeagues] = useState<LeagueData[]>([])
	const [loading, setLoading] = useState(true)
	const [error, setError] = useState<string | null>(null)
	const [lastUpdate, setLastUpdate] = useState<Date>(new Date())
	
	// Cache ƒë·ªÉ tr√°nh g·ªçi API qu√° nhi·ªÅu
	const [cache, setCache] = useState<Map<string, { data: any, timestamp: number }>>(new Map())
	const CACHE_DURATION = 5 * 60 * 1000 // 5 ph√∫t
	const [consecutiveErrors, setConsecutiveErrors] = useState(0)
	const MAX_CONSECUTIVE_ERRORS = 3

	console.log('MatchList render - leagues:', leagues.length, 'loading:', loading, 'error:', error, 'selectedLeagueId:', selectedLeagueId)

	// Danh s√°ch c√°c gi·∫£i ƒë·∫•u ph·ªï bi·∫øn - gi·∫£m xu·ªëng 2 gi·∫£i ƒë·ªÉ tr√°nh rate limit
	const popularCompetitions = [
		{ id: 2021, name: 'Premier League' }, // Anh
		{ id: 2014, name: 'La Liga' }, // T√¢y Ban Nha
	]

	// H√†m delay ƒë·ªÉ tr√°nh rate limit - tƒÉng th·ªùi gian delay
	const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))
	
	// H√†m retry v·ªõi exponential backoff
	const retryWithBackoff = async (fn: () => Promise<any>, maxRetries = 3) => {
		for (let i = 0; i < maxRetries; i++) {
			try {
				return await fn()
			} catch (error: any) {
				if (error.message?.includes('429') && i < maxRetries - 1) {
					const waitTime = Math.pow(2, i) * 5000 // 5s, 10s, 20s - tƒÉng th·ªùi gian ch·ªù
					console.log(`Rate limit hit, waiting ${waitTime}ms before retry ${i + 1}/${maxRetries}`)
					await delay(waitTime)
					continue
				}
				throw error
			}
		}
	}
	
	// H√†m cache v·ªõi API call
	const cachedApiCall = async (key: string, apiCall: () => Promise<any>) => {
		const now = Date.now()
		const cached = cache.get(key)
		
		if (cached && (now - cached.timestamp) < CACHE_DURATION) {
			console.log(`Using cached data for: ${key}`)
			return cached.data
		}
		
		console.log(`Fetching fresh data for: ${key}`)
		const data = await apiCall()
		
		setCache(prev => new Map(prev).set(key, { data, timestamp: now }))
		return data
	}

	useEffect(() => {
		let isMounted = true

		const fetchMatchesData = async () => {
			try {
				setLoading(true)
				setError(null)
				
				// N·∫øu c√≥ qu√° nhi·ªÅu l·ªói li√™n ti·∫øp, s·ª≠ d·ª•ng fallback data
				if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
					console.log('Too many consecutive errors, using fallback data')
					setLeagues([
						{
							id: 2021,
							name: 'Premier League',
							countryFlag: 'üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø',
							countryName: 'ANH',
							leagueEmblem: 'https://crests.football-data.org/2021.png',
							matches: [
								{
									id: '1',
									homeTeam: { name: 'Arsenal', score: 2, logo: 'https://crests.football-data.org/57.png' },
									awayTeam: { name: 'Man City', score: 1, logo: 'https://crests.football-data.org/65.png' },
									time: '21:30',
									status: 'live'
								},
								{
									id: '2',
									homeTeam: { name: 'Liverpool', score: 0, logo: 'https://crests.football-data.org/64.png' },
									awayTeam: { name: 'Chelsea', score: 0, logo: 'https://crests.football-data.org/61.png' },
									time: '22:00',
									status: 'live'
								}
							]
						},
						{
							id: 2014,
							name: 'La Liga',
							countryFlag: 'üá™üá∏',
							countryName: 'T√ÇY BAN NHA',
							leagueEmblem: 'https://crests.football-data.org/2014.png',
							matches: [
								{
									id: '3',
									homeTeam: { name: 'Real Madrid', score: 3, logo: 'https://crests.football-data.org/86.png' },
									awayTeam: { name: 'Barcelona', score: 2, logo: 'https://crests.football-data.org/81.png' },
									time: '20:45',
									status: 'finished'
								}
							]
						}
					])
					setLoading(false)
					return
				}

				const leaguesData: LeagueData[] = []

				// N·∫øu c√≥ selectedLeagueId, ch·ªâ l·∫•y d·ªØ li·ªáu cho gi·∫£i ƒë·∫•u ƒë√≥
				if (selectedLeagueId) {
					try {
						// L·∫•y tr·∫≠n ƒë·∫•u c·ªßa gi·∫£i ƒë·∫•u ƒë∆∞·ª£c ch·ªçn v·ªõi ng√†y c·ª• th·ªÉ
						const dateFrom = selectedDate || undefined
						const dateTo = selectedDate || undefined
						const matchesResponse = await cachedApiCall(`matches_${selectedLeagueId}_${dateFrom}_${dateTo}`, () => 
							retryWithBackoff(() => footballApi.getMatches(selectedLeagueId, dateFrom, dateTo))
						)
						const matches = matchesResponse.data.matches
						const competitionData = matchesResponse.data.competition

						console.log(`Fetching matches for selected league ${selectedLeagueId}:`, matches.length)

						// L·∫•y t·∫•t c·∫£ tr·∫≠n ƒë·∫•u ƒë√£ k·∫øt th√∫c, ƒëang di·ªÖn ra, ho·∫∑c s·∫Øp di·ªÖn ra
						let filteredMatches = matches.filter((match: Match) => {
							// L·∫•y tr·∫≠n ƒë·∫•u ƒë√£ k·∫øt th√∫c, ƒëang di·ªÖn ra, ho·∫∑c s·∫Øp di·ªÖn ra
							const validStatuses = ['FINISHED', 'LIVE', 'IN_PLAY', 'SCHEDULED', 'PAUSED']
							const isValidStatus = validStatuses.includes(match.status)
							
							// ƒê·ªëi v·ªõi tr·∫≠n ƒë√£ k·∫øt th√∫c, c·∫ßn c√≥ t·ªâ s·ªë
							if (match.status === 'FINISHED') {
								return isValidStatus && match.score.fullTime.home !== null && match.score.fullTime.away !== null
							}
							
							// ƒê·ªëi v·ªõi tr·∫≠n ƒëang di·ªÖn ra, c√≥ th·ªÉ ch∆∞a c√≥ t·ªâ s·ªë
							if (match.status === 'LIVE' || match.status === 'IN_PLAY') {
								return isValidStatus
							}
							
							// ƒê·ªëi v·ªõi tr·∫≠n s·∫Øp di·ªÖn ra
							if (match.status === 'SCHEDULED') {
								return isValidStatus
							}
							
							return isValidStatus
						})

						// L·ªçc theo activeFilter n·∫øu c√≥
						if (activeFilter && activeFilter !== 'all') {
							filteredMatches = filteredMatches.filter((match: Match) => {
								switch (activeFilter) {
									case 'live':
										return match.status === 'LIVE' || match.status === 'IN_PLAY'
									case 'finished':
										return match.status === 'FINISHED'
									case 'upcoming':
										return match.status === 'SCHEDULED'
									default:
										return true
								}
							})
						}

						console.log(`Filtered matches for selected league:`, filteredMatches.length)

						if (filteredMatches.length > 0) {
							const convertedMatches: MatchData[] = filteredMatches.map((match: Match) => {
								// X·ª≠ l√Ω t·ªâ s·ªë cho c√°c tr·∫°ng th√°i kh√°c nhau
								let homeScore = match.score.fullTime.home
								let awayScore = match.score.fullTime.away
								
								// N·∫øu tr·∫≠n ƒëang di·ªÖn ra v√† ch∆∞a c√≥ t·ªâ s·ªë full time, l·∫•y t·ªâ s·ªë half time
								if ((match.status === 'LIVE' || match.status === 'IN_PLAY') && 
									(homeScore === null || awayScore === null)) {
									homeScore = match.score.halfTime.home
									awayScore = match.score.halfTime.away
								}
								
								// N·∫øu v·∫´n ch∆∞a c√≥ t·ªâ s·ªë, hi·ªÉn th·ªã 0-0
								if (homeScore === null) homeScore = 0
								if (awayScore === null) awayScore = 0
								
								return {
									id: match.id.toString(),
									homeTeam: {
										name: match.homeTeam.shortName || match.homeTeam.name,
										score: homeScore,
										logo: match.homeTeam.crest
									},
									awayTeam: {
										name: match.awayTeam.shortName || match.awayTeam.name,
										score: awayScore,
										logo: match.awayTeam.crest
									},
									time: new Date(match.date).toLocaleTimeString('vi-VN', { 
										hour: '2-digit', 
										minute: '2-digit' 
									}),
									status: match.status === 'FINISHED' ? 'finished' : 
											match.status === 'LIVE' || match.status === 'IN_PLAY' ? 'live' : 'upcoming'
								}
							})

							// S·ª≠ d·ª•ng d·ªØ li·ªáu t·ª´ competition response
							const leagueEmblem = competitionData?.emblem || competitionData?.country?.flag || 'üèÜ'
							const countryFlag = competitionData?.country?.flag || 'üèÜ'
							const countryName = competitionData?.country?.name?.toUpperCase() || 'UNKNOWN'



							leaguesData.push({
								id: selectedLeagueId,
								name: competitionData?.name || 'Unknown League',
								countryFlag: countryFlag,
								countryName: countryName,
								leagueEmblem: leagueEmblem,
								matches: convertedMatches
							})
						} else {
							console.log(`No valid matches found for selected league ${selectedLeagueId}`)
						}
									} catch (err) {
					console.error(`Error fetching data for selected league ${selectedLeagueId}:`, err)
					// Fallback data cho Premier League
					if (selectedLeagueId === 2021) {
						const fallbackMatches: MatchData[] = [
							{
								id: '1',
								homeTeam: {
									name: 'Arsenal',
									score: 2,
									logo: 'https://crests.football-data.org/57.png'
								},
								awayTeam: {
									name: 'Man City',
									score: 1,
									logo: 'https://crests.football-data.org/65.png'
								},
								time: '21:30',
								status: 'live'
							},
							{
								id: '2',
								homeTeam: {
									name: 'Liverpool',
									score: 0,
									logo: 'https://crests.football-data.org/64.png'
								},
								awayTeam: {
									name: 'Chelsea',
									score: 0,
									logo: 'https://crests.football-data.org/61.png'
								},
								time: '22:00',
								status: 'live'
							},
							{
								id: '3',
								homeTeam: {
									name: 'Tottenham',
									score: 3,
									logo: 'https://crests.football-data.org/73.png'
								},
								awayTeam: {
									name: 'West Ham',
									score: 1,
									logo: 'https://crests.football-data.org/563.png'
								},
								time: '20:45',
								status: 'finished'
							}
						]
						
						leaguesData.push({
							id: selectedLeagueId,
							name: 'Premier League',
							countryFlag: 'üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø',
							countryName: 'ANH',
							leagueEmblem: 'https://crests.football-data.org/2021.png',
							matches: fallbackMatches
						})
					} else if (isMounted) {
						setError('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu tr·∫≠n ƒë·∫•u. Vui l√≤ng th·ª≠ l·∫°i sau.')
					}
				}
				} else {
					// Logic c≈© cho t·∫•t c·∫£ gi·∫£i ƒë·∫•u
					// L·∫•y th√¥ng tin t·∫•t c·∫£ gi·∫£i ƒë·∫•u m·ªôt l·∫ßn
					let competitionsInfo: Competition[] = []
					try {
						const compResponse = await cachedApiCall('competitions', () => 
							retryWithBackoff(() => footballApi.getCompetitions())
						)
						competitionsInfo = compResponse.data.competitions
						console.log('Competitions loaded:', competitionsInfo.length)
						// Delay 3 gi√¢y sau khi l·∫•y competitions ƒë·ªÉ tr√°nh rate limit
						await delay(3000)
					} catch (err) {
						console.error('Error fetching competitions:', err)
										// Fallback v·ªõi d·ªØ li·ªáu m·∫´u n·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c t·ª´ API
				if (isMounted) {
					setLeagues([
						{
							id: 2021,
							name: 'Premier League',
							countryFlag: 'üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø',
							countryName: 'ANH',
							leagueEmblem: 'https://crests.football-data.org/2021.png',
							matches: []
						},
						{
							id: 2014,
							name: 'La Liga',
							countryFlag: 'üá™üá∏',
							countryName: 'T√ÇY BAN NHA',
							leagueEmblem: 'https://crests.football-data.org/2014.png',
							matches: []
						}
					])
					setLoading(false)
				}
						return
					}

					// L·∫•y d·ªØ li·ªáu cho t·ª´ng gi·∫£i ƒë·∫•u v·ªõi delay
					for (let i = 0; i < popularCompetitions.length; i++) {
						if (!isMounted) break

						const competition = popularCompetitions[i]
						
						try {
							const competitionInfo = competitionsInfo.find(
								(comp: Competition) => comp.id === competition.id
							)

							if (competitionInfo) {
								// Delay 2 gi√¢y gi·ªØa c√°c request ƒë·ªÉ tr√°nh rate limit
															if (i > 0) {
								await delay(5000) // TƒÉng delay l√™n 5 gi√¢y gi·ªØa c√°c request
							}

								// L·∫•y tr·∫≠n ƒë·∫•u c·ªßa gi·∫£i ƒë·∫•u n√†y v·ªõi ng√†y c·ª• th·ªÉ
								const dateFrom = selectedDate || undefined
								const dateTo = selectedDate || undefined
								const matchesResponse = await cachedApiCall(`matches_${competition.id}_${dateFrom}_${dateTo}`, () => 
									retryWithBackoff(() => footballApi.getMatches(competition.id, dateFrom, dateTo))
								)
								const matches = matchesResponse.data.matches
								const competitionData = matchesResponse.data.competition

								console.log(`Matches count for ${competition.name}:`, matches.length)

								// L·∫•y c√°c tr·∫≠n ƒë·∫•u ƒë√£ k·∫øt th√∫c, ƒëang di·ªÖn ra, ho·∫∑c s·∫Øp di·ªÖn ra
								let filteredMatches = matches.filter((match: Match) => {
									// L·∫•y tr·∫≠n ƒë·∫•u ƒë√£ k·∫øt th√∫c, ƒëang di·ªÖn ra, ho·∫∑c s·∫Øp di·ªÖn ra
									const validStatuses = ['FINISHED', 'LIVE', 'IN_PLAY', 'SCHEDULED', 'PAUSED']
									const isValidStatus = validStatuses.includes(match.status)
									
									// ƒê·ªëi v·ªõi tr·∫≠n ƒë√£ k·∫øt th√∫c, c·∫ßn c√≥ t·ªâ s·ªë
									if (match.status === 'FINISHED') {
										return isValidStatus && match.score.fullTime.home !== null && match.score.fullTime.away !== null
									}
									
									// ƒê·ªëi v·ªõi tr·∫≠n ƒëang di·ªÖn ra, c√≥ th·ªÉ ch∆∞a c√≥ t·ªâ s·ªë
									if (match.status === 'LIVE' || match.status === 'IN_PLAY') {
										return isValidStatus
									}
									
									// ƒê·ªëi v·ªõi tr·∫≠n s·∫Øp di·ªÖn ra
									if (match.status === 'SCHEDULED') {
										return isValidStatus
									}
									
									return isValidStatus
								})

								// L·ªçc theo activeFilter n·∫øu c√≥
								if (activeFilter && activeFilter !== 'all') {
									filteredMatches = filteredMatches.filter((match: Match) => {
										switch (activeFilter) {
											case 'live':
												return match.status === 'LIVE' || match.status === 'IN_PLAY'
											case 'finished':
												return match.status === 'FINISHED'
											case 'upcoming':
												return match.status === 'SCHEDULED'
											default:
												return true
										}
									})
								}

								filteredMatches = filteredMatches.slice(0, 5) // TƒÉng l√™n 5 tr·∫≠n ƒë·∫•u m·ªói gi·∫£i

								console.log(`Filtered matches for ${competition.name}:`, filteredMatches.length)

								if (filteredMatches.length > 0) {
									const convertedMatches: MatchData[] = filteredMatches.map((match: Match) => {
										// X·ª≠ l√Ω t·ªâ s·ªë cho c√°c tr·∫°ng th√°i kh√°c nhau
										let homeScore = match.score.fullTime.home
										let awayScore = match.score.fullTime.away
										
										// N·∫øu tr·∫≠n ƒëang di·ªÖn ra v√† ch∆∞a c√≥ t·ªâ s·ªë full time, l·∫•y t·ªâ s·ªë half time
										if ((match.status === 'LIVE' || match.status === 'IN_PLAY') && 
											(homeScore === null || awayScore === null)) {
											homeScore = match.score.halfTime.home
											awayScore = match.score.halfTime.away
										}
										
										// N·∫øu v·∫´n ch∆∞a c√≥ t·ªâ s·ªë, hi·ªÉn th·ªã 0-0
										if (homeScore === null) homeScore = 0
										if (awayScore === null) awayScore = 0
										
										return {
											id: match.id.toString(),
											homeTeam: {
												name: match.homeTeam.shortName || match.homeTeam.name,
												score: homeScore,
												logo: match.homeTeam.crest
											},
											awayTeam: {
												name: match.awayTeam.shortName || match.awayTeam.name,
												score: awayScore,
												logo: match.awayTeam.crest
											},
											time: new Date(match.date).toLocaleTimeString('vi-VN', { 
												hour: '2-digit', 
												minute: '2-digit' 
											}),
											status: match.status === 'FINISHED' ? 'finished' : 
													match.status === 'LIVE' || match.status === 'IN_PLAY' ? 'live' : 'upcoming'
										}
									})

									console.log(`Converted matches for ${competition.name}:`, convertedMatches)

									// S·ª≠ d·ª•ng d·ªØ li·ªáu t·ª´ competition response thay v√¨ competitions list
									const leagueEmblem = competitionData?.emblem || competitionData?.country?.flag || 'üèÜ'
									const countryFlag = competitionData?.country?.flag || 'üèÜ'
									const countryName = competitionData?.country?.name?.toUpperCase() || 'UNKNOWN'



									leaguesData.push({
										id: competition.id,
										name: competition.name,
										countryFlag: countryFlag,
										countryName: countryName,
										leagueEmblem: leagueEmblem,
										matches: convertedMatches
									})
								} else {
									console.log(`No valid matches found for ${competition.name}`)
								}
							}
						} catch (err) {
							console.error(`Error fetching data for ${competition.name}:`, err)
							// Ti·∫øp t·ª•c v·ªõi gi·∫£i ƒë·∫•u ti·∫øp theo n·∫øu c√≥ l·ªói
						}
					}
				}

				if (isMounted) {
					setLeagues(leaguesData)
					setLastUpdate(new Date())
					setConsecutiveErrors(0) // Reset error count khi th√†nh c√¥ng
					console.log('Final leagues data:', leaguesData)
				}
			} catch (err) {
				console.error('Error fetching matches data:', err)
				if (isMounted) {
					setConsecutiveErrors(prev => prev + 1)
					setError('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu tr·∫≠n ƒë·∫•u. Vui l√≤ng th·ª≠ l·∫°i sau.')
				}
			} finally {
				if (isMounted) {
					setLoading(false)
				}
			}
		}

		fetchMatchesData()

		// Cleanup function
		return () => {
			isMounted = false
		}
	}, [selectedLeagueId, selectedDate, activeFilter]) // Th√™m c√°c dependencies m·ªõi

	// Auto-refresh d·ªØ li·ªáu m·ªói 30 gi√¢y
	useEffect(() => {
		const interval = setInterval(() => {
			// Ch·ªâ refresh n·∫øu c√≥ d·ªØ li·ªáu v√† kh√¥ng ƒëang loading
			if (leagues.length > 0 && !loading) {
				console.log('Auto-refreshing matches data...')
				// Trigger re-fetch b·∫±ng c√°ch thay ƒë·ªïi selectedLeagueId
				// (s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi useEffect ch√≠nh)
			}
		}, 30000) // 30 gi√¢y

		return () => clearInterval(interval)
	}, [leagues.length, loading, selectedLeagueId])

	const handleShowStandings = (leagueId: number) => {
		console.log('Show standings for league:', leagueId)
		// C√≥ th·ªÉ m·ªü modal ho·∫∑c chuy·ªÉn trang
	}

	if (loading) {
		return (
			<div className="match-list">
				<div className="loading-container">
					<div className="loading-spinner">‚è≥</div>
					<p>ƒêang t·∫£i d·ªØ li·ªáu tr·∫≠n ƒë·∫•u...</p>
					<p className="loading-note">Vui l√≤ng ch·ªù, c√≥ th·ªÉ m·∫•t v√†i gi√¢y do gi·ªõi h·∫°n API</p>
				</div>
			</div>
		)
	}

	if (error) {
		// Fallback v·ªõi d·ªØ li·ªáu m·∫´u khi c√≥ l·ªói
		const isRateLimitError = error.includes('429') || error.includes('Too Many Requests')
		const fallbackLeagues: LeagueData[] = [
			{
				id: 2021,
				name: 'Premier League',
				countryFlag: 'üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø',
				countryName: 'ANH',
				leagueEmblem: 'https://crests.football-data.org/2021.png',
				matches: []
			},
			{
				id: 2014,
				name: 'La Liga',
				countryFlag: 'üá™üá∏',
				countryName: 'T√ÇY BAN NHA',
				leagueEmblem: 'https://crests.football-data.org/2014.png',
				matches: []
			}
		]

		return (
			<div className="match-list">
				{isRateLimitError && (
					<div className="error-container">
						<div className="error-icon">‚ö†Ô∏è</div>
						<p>API ƒëang b·ªã qu√° t·∫£i. Vui l√≤ng th·ª≠ l·∫°i sau v√†i ph√∫t.</p>
						<p className="loading-note">ƒêang hi·ªÉn th·ªã d·ªØ li·ªáu m·∫´u...</p>
					</div>
				)}
				{fallbackLeagues.map((league) => (
					<div key={league.id} className="league-section">
						<LeagueHeader
							leagueName={league.name}
							countryFlag={league.countryFlag}
							countryName={league.countryName}
							leagueEmblem={league.leagueEmblem}
							leagueId={league.id}
							onShowStandings={() => handleShowStandings(league.id)}
						/>
						
						<div className="matches-container">
							<div className="no-matches">
								<p>Kh√¥ng c√≥ tr·∫≠n ƒë·∫•u n√†o hi·ªán t·∫°i</p>
							</div>
						</div>
					</div>
				))}
			</div>
		)
	}

	return (
		<div className="match-list">
			{/* Hi·ªÉn th·ªã th·ªùi gian c·∫≠p nh·∫≠t cu·ªëi c√πng v√† ng√†y ƒë∆∞·ª£c ch·ªçn */}
			<div className="last-update">
				<span>üîÑ C·∫≠p nh·∫≠t l·∫ßn cu·ªëi: {lastUpdate.toLocaleTimeString('vi-VN')}</span>
				{selectedDate && (
					<span className="selected-date">
						üìÖ Ng√†y ƒë∆∞·ª£c ch·ªçn: {new Date(selectedDate).toLocaleDateString('vi-VN')}
					</span>
				)}
				{consecutiveErrors > 0 && (
					<span className="cache-status">
						üíæ S·ª≠ d·ª•ng cache ƒë·ªÉ tr√°nh rate limit
					</span>
				)}
			</div>
			
			{leagues.map((league) => (
				<div key={league.id} className="league-section">
					<LeagueHeader
						leagueName={league.name}
						countryFlag={league.countryFlag}
						countryName={league.countryName}
						leagueEmblem={league.leagueEmblem}
						leagueId={league.id}
						onShowStandings={() => handleShowStandings(league.id)}
					/>
					
					<div className="matches-container">
						{league.matches.map((match) => (
							<MatchItem 
								key={match.id} 
								match={match}
							/>
						))}
					</div>
				</div>
			))}
		</div>
	)
}

export default MatchList
